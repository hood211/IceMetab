---
title: "ERanalysis"
author: "JMH"
date: "10/27/2020"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```



# Analysis of GPP response to N and P enrichment
## Libraries
```{r message=FALSE, warning=FALSE}
library(tidyverse)
library(gamm4)
library(mgcViz)
library(MuMIn)
library(forecast)
library(gridExtra)
library(tidymv)

```

## Load & munge data

Loads data, calculates log GPP and ER, does a ridiculous transformation of NEP, and centers stream water temp at 10C as inverse kT
```{r message=FALSE, warning=FALSE}
met2 <- read.csv("00_metab_for_Hoodie.csv") %>% 
  mutate(Pdt = as.POSIXct(Pdt, format = "%m/%d/%y"),
         doy = as.numeric(strftime(Pdt, format = "%j")),
         Y = as.numeric(strftime(Pdt, format = "%Y")),
         Yf = as.factor(as.character(Y)),
         lGPP = log(GPP_median),
         lER = log(-ER_median),
         #centering
         invKT.C = one_over_kT - 1/((10 + 273.15)*0.0000862),
         streamTreat = as.factor(paste0(stream,"_",treatment))) %>% 
  mutate_at(vars(stream, treatment), funs(as.factor(.))) %>% 
  rename(invKT = one_over_kT)
```

For predictor variables, we want to center Temp, light, Q, and GPP. We'll do that using stream means, which we calculate below
```{r}
# stream mean
metS <- met2 %>% 
  group_by(stream, treatment) %>% 
  summarise_at(vars(meanTemp, invKT.C, meanQds, LightPerDay, lGPP), funs(mean(., na.rm = TRUE))) %>% 
  group_by(stream) %>% 
  summarise_at(vars(meanTemp, invKT.C, meanQds, LightPerDay, lGPP), funs(mean(., na.rm = TRUE))) %>% 
  rename_at(vars(-stream), function(x) paste0(x,".StMean"))

# global mean
metG0 <- met2 %>% 
  group_by(stream, treatment) %>% 
  summarise_at(vars(meanTemp, invKT.C, meanQds, LightPerDay, lGPP), funs(mean(., na.rm = TRUE))) %>% 
  group_by(stream) %>% 
  summarise_at(vars(meanTemp, invKT.C, meanQds, LightPerDay, lGPP), funs(mean(., na.rm = TRUE))) %>% 
  group_by() %>% 
  summarise_at(vars(meanTemp, invKT.C, meanQds, LightPerDay, lGPP), funs(mean(., na.rm = TRUE)))%>% 
  rename_at(vars(meanTemp:lGPP), function(x) paste0(x,".GMean"))

metG <- rbind(metG0, metG0, metG0, metG0)
metG$stream <- c("st11U", "st18", "st6", "st9")
```

Now, we log transform Q, GPP, and light then center on mean logged value (you can't center then log). 
```{r}
met <- met2 %>% 
  full_join(metS, by = "stream") %>% 
  full_join(metG, by = "stream") %>% 
  #these are centered on the stream mean
  mutate(Tanom.iktCs = invKT.C - invKT.C.StMean, 
         Tanom.iktCg = invKT.C - invKT.C.GMean, 
         Tanom.Cs = meanTemp - meanTemp.StMean,
         Tanom.Cg = meanTemp - meanTemp.GMean,
         LightPerDayCs = LightPerDay - LightPerDay.StMean,
         LightPerDayCg = LightPerDay - LightPerDay.GMean,
         meanQdsCs = meanQds - meanQds.StMean,
         meanQdsCg = meanQds - meanQds.GMean,
         LightPerDay.l = log(LightPerDay),
         meanQds.l = log(meanQds),
         LightPerDay.lcs = LightPerDay.l - log(LightPerDay.StMean),
         LightPerDay.lcg = LightPerDay.l - log(LightPerDay.GMean),
         meanQds.lcs = meanQds.l - log(meanQds.StMean),
         meanQds.lcg = meanQds.l - log(meanQds.GMean),
         lGPP.cs = lGPP - lGPP.StMean,
         lGPP.cg = lGPP - lGPP.GMean,
         streamTreat = paste0(stream," ", treatment),
         stream = as.factor(stream))
```

## Quick visualization
### ER
Focus on ER response.


```{r echo=FALSE}
ggplot(met, aes(y = log(-ER_median), x = doy, color = Yf)) +
  geom_line() +
  facet_grid(. ~ stream)
```

Access normality: 
log ER - not terrible

```{r echo=FALSE}
ggplot(met, aes(sample = lER, color = stream)) +stat_qq() + stat_qq_line() +
  facet_grid(.~stream)
```


### Light
Untransformed daily integrated light

```{r echo=FALSE}
ggplot(met, aes(y = LightPerDay, x = doy, color = Yf)) +
  geom_line() +
  facet_grid(. ~ stream)
```

log-centered daily integrated light - stream

```{r echo=FALSE}
ggplot(met, aes(y = LightPerDay.lcs, x = doy, color = Yf)) +
  geom_line() +
  facet_grid(. ~ stream)
```

log-centered daily integrated light - global

```{r echo=FALSE}
ggplot(met, aes(y = LightPerDay.lcg, x = doy, color = Yf)) +
  geom_line() +
  facet_grid(. ~ stream)
```

Is light normal? Probably close enough.

```{r echo=FALSE}
ggplot(met, aes(sample = LightPerDay.lcg, color = stream)) +stat_qq() + stat_qq_line()+
  facet_grid(.~stream)
```

### Discharge
Untransformed mean daily Q.

```{r echo=FALSE}
ggplot(met, aes(y = meanQds, x = doy, color = Yf)) +
  geom_line() +
  facet_grid(. ~ stream)
```

log-centered mean daily Q -stream
```{r echo=FALSE}
ggplot(met, aes(y = meanQds.lcs, x = doy, color = Yf)) +
  geom_line() +
  facet_grid(. ~ stream)
```

log-centered mean daily Q - global
```{r echo=FALSE}
ggplot(met, aes(y = meanQds.lcg, x = doy, color = Yf)) +
  geom_line() +
  facet_grid(. ~ stream)
```


Is it normal. Log centered mean daily Q.

```{r echo=FALSE}
ggplot(met, aes(sample = meanQds.lcg)) +stat_qq() + stat_qq_line()+
  facet_grid(.~stream)
```

### Temperature as 1/kT
Untransformed temperature

```{r echo=FALSE}
ggplot(met, aes(y = invKT, x = doy, color = Yf)) +
  geom_line() +
  facet_grid(. ~ stream)
```

Temperature anom based on mean stream temp

```{r echo=FALSE}
ggplot(met, aes(y = Tanom.iktCs, x = doy, color = Yf)) +
  geom_line() +
  facet_grid(. ~ stream)
```

Temperature anom based on mean stream temp - global

```{r echo=FALSE}
ggplot(met, aes(y = Tanom.iktCg, x = doy, color = Yf)) +
  geom_line() +
  facet_grid(. ~ stream)
```

Normal? - looks awesome!

```{r echo=FALSE}
ggplot(met, aes(sample = Tanom.iktCg, color = stream)) +stat_qq() + stat_qq_line()+
  facet_grid(.~stream)
```

### GPP
Is really important and there's super interesting things going on between ER and GPP, but I'm going to leave out.
```{r}
ggplot(met, aes(y = lER, x = lGPP.cg, color = stream, shape = treatment)) +geom_point() +facet_grid(stream~.)
```


Normal? - S18 has particularly long tails
```{r echo=FALSE}
ggplot(met, aes(sample = lGPP.cg, color = stream)) +stat_qq() + stat_qq_line()+
  facet_grid(.~stream)
```


```{r}
ggplot(met, aes(y = log(-ER_median), x = meanQds.lcg, color = Yf)) +
  geom_point() +
  facet_grid(. ~ stream)
```


Ugh - Q and temp are correlated
These can't be in the same model

```{r}
ggplot(met, aes(y = meanQdsCg, x = Tanom.iktCg, color = stream)) +
  geom_point() +
  facet_grid(stream ~.)

met %>% 
  group_by(stream) %>% 
  summarize(currelation = cor(meanQdsCg, Tanom.iktCg))

```




## ER v. temp

```{r}
ggplot(met, aes(y = lER, x = Tanom.iktCg, color = Yf, shape = stream)) +
  geom_point() 
```

```{r}
ggplot(met, aes(y = lER, x = Tanom.iktCg, color = Yf)) +
  geom_point() +
  facet_grid(stream ~.)
```



```{r}
ggplot(met, aes(y = lER, x = invKT.C.StMean, color = Yf, shape = stream)) +
  geom_point(position = "jitter") 
```
```{r}
ggplot(met, aes(y = lER, x = invKT.C.GMean, color = Yf, shape = stream)) +
  geom_point(position = "jitter") 
```

# ER models

Likely maximal model
```{r}
g.er.PutGLOB0 <- gamm(lER ~ treatment*invKT.C.StMean +  s(meanQds.lcg, by = stream) , REML = FALSE, data = met)

g.er.PutGLOB1 <- gamm(lER ~ treatment*invKT.C.StMean +  s(meanQds.lcg, by = stream) + 
                     s(lGPP.cg, by = stream), REML = FALSE, data = met)

g.er.PutGLOB1a <- gamm(lER ~ treatment*invKT.C.StMean +  s(meanQds.lcg, by = stream), REML = FALSE, data = met)


# this is perhaps the most intuitive, but it doesn't work
# g.er.PutGLOB1 <- gamm(lER ~ s(invKT.C.StMean, by = treatment) +  s(meanQds.lc, by = stream) + 
#                      s(LightPerDay.lc, by = stream) + s(Tanom.iktC, by = stream), REML = FALSE, data = met)
```

```{r}
model.sel(g.er.PutGLOB0$lme, g.er.PutGLOB1$lme, g.er.PutGLOB1a$lme)
```


```{r}
summary(g.er.PutGLOB1$gam)
```

```{r}
g.er.PutGLOB0.b <- getViz(g.er.PutGLOB1$gam)
```

```{r}
check(g.er.PutGLOB0.b)
```


So autocorrelation
```{r}
# https://www.kaggle.com/timib1203/managing-many-models-with-tidyr-purrr-and-broom
met.PutGLOB <- met %>% 
  mutate(g.erRes = resid(g.er.PutGLOB1$lme, type = "normalized")) %>% 
  select(streamTreat, g.erRes) %>% 
  group_by(streamTreat) %>% 
  nest() %>% 
  mutate(acf = map(.x = data, .f = function(d) ggAcf(d$g.erRes) + labs(title = streamTreat)))
```

```{r}
grid.arrange(grobs = met.PutGLOB$acf, ncol = 3)
```


Evaluate different corr structures
```{r}
g.er.AC_1.0 <- gamm(lER ~ treatment*invKT.C.StMean +  s(meanQds.lcg, by = stream),
                correlation = corARMA(p = 1,q = 0, form = ~ doy | streamTreat), REML = FALSE, data = met)

g.er.AC_1.1 <- gamm(lER ~ treatment*invKT.C.StMean +  s(meanQds.lcg, by = stream),
                correlation = corARMA(p = 1,q = 1, form = ~ doy | streamTreat), REML = FALSE, data = met)

g.er.AC_1.2 <- gamm(lER ~ treatment*invKT.C.StMean +  s(meanQds.lcg, by = stream),
                correlation = corARMA(p = 1,q = 2, form = ~ doy | streamTreat), REML = FALSE, data = met)

g.er.AC_2.0 <- gamm(lER ~ treatment*invKT.C.StMean +  s(meanQds.lcg, by = stream),
                correlation = corARMA(p = 2,q = 0, form = ~ doy | streamTreat), REML = FALSE, data = met)


g.er.AC_2.1 <- gamm(lER ~ treatment*invKT.C.StMean +  s(meanQds.lcg, by = stream),
                correlation = corARMA(p = 2,q = 1, form = ~ doy | streamTreat), REML = FALSE, data = met)

g.er.AC_2.2 <- gamm(lER ~ treatment*invKT.C.StMean +  s(meanQds.lcg, by = stream),
                correlation = corARMA(p = 2,q = 2, form = ~ doy | streamTreat), REML = FALSE, data = met)
# doesn't work
g.er.AC_3.0 <- gamm(lER ~ treatment*invKT.C.StMean +  s(meanQds.lcg, by = stream),
                correlation = corARMA(p = 3,q = 0, form = ~ doy | streamTreat), REML = FALSE, data = met)

g.er.AC_3.1 <- gamm(lER ~ treatment*invKT.C.StMean +  s(meanQds.lcg, by = stream),
                correlation = corARMA(p = 3,q = 1, form = ~ doy | streamTreat), REML = FALSE, data = met)
# 
g.er.AC_3.2 <- gamm(lER ~ treatment*invKT.C.StMean +  s(meanQds.lcg, by = stream),
                correlation = corARMA(p = 3,q = 2, form = ~ doy | streamTreat), REML = FALSE, data = met)
```

Model selection
```{r}
model.sel(g.er.AC_1.0$lme, g.er.AC_1.1$lme, g.er.AC_1.2$lme, g.er.AC_2.0$lme,
          g.er.AC_2.1$lme, g.er.AC_2.2$lme, g.er.AC_3.0$lme, g.er.AC_3.1$lme, g.er.AC_3.2$lme) 

```


Much better. S6p, s6n, s9a, s9p, s11u still have some minor problems
```{r}

# https://www.kaggle.com/timib1203/managing-many-models-with-tidyr-purrr-and-broom
# https://jroy042.github.io/nonlinear/week4.html
# https://stackoverflow.com/questions/47586110/autocorrelation-in-generalized-additive-models-gam
g.er.AC_best.acf <- met %>% 
  mutate(g.erRes = resid(g.er.AC_3.2$lme, type = "normalized")) %>% 
  select(streamTreat, g.erRes) %>% 
  group_by(streamTreat) %>% 
  nest() %>% 
  mutate(acf = map(.x = data, .f = function(d) ggAcf(d$g.erRes) + labs(title = streamTreat)))
```

```{r}
grid.arrange(grobs = g.er.AC_best.acf$acf, ncol = 3)
```


Let's do some model selection. Thinking about this as our base model has Q, temp, and light. I'm not going to obsess about selecting those. Instead, I'll just focus on Annual Temp and treatment

going to use a simpler one, problems fitting models with 3.0
```{r}
BestERCor <- corARMA(p = 3,q = 2, form = ~ doy | streamTreat)
```


```{r}
# did quick check to see if I need T anom by stream - yes massive improvement in AIC
# also did check to see if I needed GPP x stream - nope! 
# GLOBAL CENTERED Q
g.er.NutXT <- gamm(lER ~ treatment*invKT.C.StMean +  s(meanQds.lcg, by = stream),
                correlation = BestERCor, REML = FALSE, data = met)

g.er.NutpT <- gamm(lER ~ treatment + invKT.C.StMean +  s(meanQds.lcg, by = stream),
                correlation = BestERCor, REML = FALSE, data = met)
g.er.NutpTs <- gamm(lER ~ treatment + invKT.C.StMean +  s(meanQds.lcs, by = stream),
                correlation = BestERCor, REML = FALSE, data = met)

g.er.NutpTb <- gamm(lER ~ treatment + invKT.C.StMean +  s(meanQds.lcg),
                correlation = BestERCor, REML = FALSE, data = met)

g.er.NutXst <- gamm(lER ~ treatment*stream +  s(meanQds.lcg, by = stream),
                correlation = BestERCor, REML = FALSE, data = met)

g.er.Nutpst <- gamm(lER ~ treatment + stream +  s(meanQds.lcg, by = stream),
                correlation = BestERCor, REML = FALSE, data = met)

g.er.Nut <- gamm(lER ~ treatment +  s(meanQds.lcg, by = stream),
                correlation = BestERCor, REML = FALSE, data = met)

g.er.T <- gamm(lER ~ invKT.C.StMean +  s(meanQds.lcg, by = stream),
                correlation = BestERCor, REML = FALSE, data = met)

g.er.st <- gamm(lER ~ stream +  s(meanQds.lcg, by = stream),
                correlation = BestERCor, REML = FALSE, data = met)

g.er.null <- gamm(lER ~ s(meanQds.lcg, by = stream),
                correlation = BestERCor, REML = FALSE, data = met) 

# STREAM CENTERED Q
g.er.NutXTs <- gamm(lER ~ treatment*invKT.C.StMean +  s(meanQds.lcs, by = stream),
                correlation = BestERCor, REML = FALSE, data = met)

g.er.NutpTs <- gamm(lER ~ treatment + invKT.C.StMean +  s(meanQds.lcs, by = stream),
                correlation = BestERCor, REML = FALSE, data = met)

g.er.NutXsts <- gamm(lER ~ treatment*stream +  s(meanQds.lcs, by = stream),
                correlation = BestERCor, REML = FALSE, data = met)

g.er.Nutpsts <- gamm(lER ~ treatment + stream +  s(meanQds.lcs, by = stream),
                correlation = BestERCor, REML = FALSE, data = met)

g.er.Nuts <- gamm(lER ~ treatment +  s(meanQds.lcs, by = stream),
                correlation = BestERCor, REML = FALSE, data = met)

g.er.Ts <- gamm(lER ~ invKT.C.StMean +  s(meanQds.lcs, by = stream),
                correlation = BestERCor, REML = FALSE, data = met)

g.er.sts <- gamm(lER ~ stream +  s(meanQds.lcs, by = stream),
                correlation = BestERCor, REML = FALSE, data = met)

g.er.nulls <- gamm(lER ~ s(meanQds.lcs, by = stream),
                correlation = BestERCor, REML = FALSE, data = met) 

```


Probably a tie between treatment and treatment + temp 
But the model with a stream centered Q is wicked better


```{r}
model.sel(g.er.NutXT$lme, g.er.NutpT$lme, g.er.NutXst$lme, g.er.Nutpst$lme, g.er.Nut$lme, g.er.T$lme, g.er.st$lme, g.er.null$lme, g.er.NutpTb$lme,
          g.er.NutXTs$lme, g.er.NutpTs$lme, g.er.NutXsts$lme, g.er.Nutpsts$lme, g.er.Nuts$lme, g.er.Ts$lme, g.er.sts$lme, g.er.nulls$lme)
```


```{r}
summary(g.er.NutpTs$gam)
```


```{r}
g.er.NutpT.b <- getViz(g.er.NutpTs$gam)
```

This model violates some shit!!! 

```{r}
check(g.er.NutpT.b)
```

```{r}
hist(resid(g.er.NutpT$lme, type = "normalized"))
```


```{r}
g.er.NutpT.acf <- met %>% 
  mutate(g.erRes = resid(g.er.NutpTs$lme, type = "normalized")) %>% 
  select(streamTreat, g.erRes) %>% 
  group_by(streamTreat) %>% 
  nest() %>% 
  mutate(acf = map(.x = data, .f = function(d) ggAcf(d$g.erRes) + labs(title = streamTreat)))
```

```{r}
grid.arrange(grobs = g.er.NutpT.acf$acf, ncol = 3)
```

```{r}
met$BestMod <- predict.gam(g.er.NutpTs$gam, met, type = "response")
```

```{r}
ggplot(met, aes(y = lER, x = BestMod, color = treatment)) +
  geom_point()+
  facet_grid(stream ~.) +
  geom_abline(intercept = 0, slope =1)
```


```{r}
print(plot(g.er.NutpT.b, allTerms = T), pages = 1)
```


In the splines, this shows all the data!
```{r}
blah <- plot(g.er.NutpT.b, allTerms = 1) +
  l_points(color = "blue") + l_fitLine(linetype = 3) + l_fitContour() + 
      l_ciLine(colour = 2) + l_ciBar() + l_fitPoints(size = 1, col = 2) + theme_get() + labs(title = NULL)

print(blah, pages = 1)
```










```{r}
save.image("01_ERanalysis_rdat")
# load("01_ERanalysis_rdat")
```

