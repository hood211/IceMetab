---
title: "ERanalysis"
author: "JMH"
date: "10/27/2020"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```



# Analysis of GPP response to N and P enrichment
## Libraries
```{r message=FALSE, warning=FALSE}
library(tidyverse)
library(gamm4)
library(mgcViz)
library(MuMIn)
library(forecast)
library(gridExtra)
library(tidymv)

```

## Load & munge data

Loads data, calculates log GPP and ER, does a ridiculous transformation of NEP, and centers stream water temp at 10C as inverse kT
```{r message=FALSE, warning=FALSE}
met2 <- read.csv("00_metab_for_Hoodie.csv") %>% 
  mutate(Pdt = as.POSIXct(Pdt, format = "%m/%d/%y"),
         doy = as.numeric(strftime(Pdt, format = "%j")),
         Y = as.numeric(strftime(Pdt, format = "%Y")),
         Yf = as.factor(as.character(Y)),
         lGPP = log(GPP_median),
         lER = log(-ER_median),
         #centering
         invKT.C = one_over_kT - 1/((10 + 273.15)*0.0000862),
         streamTreat = as.factor(paste0(stream,"_",treatment))) %>% 
  mutate_at(vars(stream, treatment), funs(as.factor(.))) %>% 
  rename(invKT = one_over_kT)
```

For predictor variables, we want to center Temp, light, Q, and GPP. We'll do that using stream means, which we calculate below
```{r}
metS <- met2 %>% 
  group_by(stream, treatment) %>% 
  summarise_at(vars(meanTemp, invKT.C, meanQds, LightPerDay, lGPP), funs(mean(., na.rm = TRUE))) %>% 
  group_by(stream) %>% 
  summarise_at(vars(meanTemp, invKT.C, meanQds, LightPerDay, lGPP), funs(mean(., na.rm = TRUE)))
names(metS)[2:6] <- paste0(names(metS)[2:6],".StMean")
```

Now, we log transform Q, GPP, and light then center on mean logged value (you can't center then log). 
```{r}
met <- met2 %>% 
  full_join(metS, by = "stream") %>% 
  #these are centered on the stream mean
  mutate(Tanom.iktC = invKT.C - invKT.C.StMean, 
         Tanom.C = meanTemp - meanTemp.StMean, 
         LightPerDayC = LightPerDay - LightPerDay.StMean,
         meanQdsC = meanQds - meanQds.StMean,
         LightPerDay.l = log(LightPerDay),
         meanQds.l = log(meanQds),
         LightPerDay.lc = LightPerDay.l - log(LightPerDay.StMean),
         meanQds.lc = meanQds.l - log(meanQds.StMean),
         lGPP.c = lGPP - lGPP.StMean,
         streamTreat = paste0(stream," ", treatment))
```

## Quick visualization
### ER
Focus on ER response.


```{r echo=FALSE}
ggplot(met, aes(y = log(-ER_median), x = doy, color = Yf)) +
  geom_line() +
  facet_grid(. ~ stream)
```

Access normality: 
log ER - not terrible

```{r echo=FALSE}
ggplot(met, aes(sample = lER, color = stream)) +stat_qq() + stat_qq_line() +
  facet_grid(.~stream)
```


### Light
Untransformed daily integrated light

```{r echo=FALSE}
ggplot(met, aes(y = LightPerDay, x = doy, color = Yf)) +
  geom_line() +
  facet_grid(. ~ stream)
```

log-centered daily integrated light

```{r echo=FALSE}
ggplot(met, aes(y = LightPerDay.lc, x = doy, color = Yf)) +
  geom_line() +
  facet_grid(. ~ stream)
```

Is light normal? Probably close enough.

```{r echo=FALSE}
ggplot(met, aes(sample = LightPerDay.lc, color = stream)) +stat_qq() + stat_qq_line()+
  facet_grid(.~stream)
```

### Discharge
Untransformed mean daily Q.

```{r echo=FALSE}
ggplot(met, aes(y = meanQds, x = doy, color = Yf)) +
  geom_line() +
  facet_grid(. ~ stream)
```

log-centered mean daily Q


```{r echo=FALSE}
ggplot(met, aes(y = meanQds.lc, x = doy, color = Yf)) +
  geom_line() +
  facet_grid(. ~ stream)
```


Is it normal. Log centered mean daily Q.


```{r echo=FALSE}
ggplot(met, aes(sample = meanQds.lc)) +stat_qq() + stat_qq_line()+
  facet_grid(.~stream)
```

### Temperature as 1/kT
Untransformed temperature

```{r echo=FALSE}
ggplot(met, aes(y = invKT, x = doy, color = Yf)) +
  geom_line() +
  facet_grid(. ~ stream)
```

Temperature anom based on mean stream temp

```{r echo=FALSE}
ggplot(met, aes(y = Tanom.iktC, x = doy, color = Yf)) +
  geom_line() +
  facet_grid(. ~ stream)
```

Normal? - looks awesome!

```{r echo=FALSE}
ggplot(met, aes(sample = Tanom.iktC, color = stream)) +stat_qq() + stat_qq_line()+
  facet_grid(.~stream)
```

### GPP
Is really important and there's super interesting things going on between ER and GPP, but I'm going to leave out.
```{r}
ggplot(met, aes(y = lER, x = lGPP.c, color = stream, shape = treatment)) +geom_point() +facet_grid(stream~.)
```


Normal? - S18 has particularly long tails
```{r echo=FALSE}
ggplot(met, aes(sample = lGPP.c, color = stream)) +stat_qq() + stat_qq_line()+
  facet_grid(.~stream)
```


```{r}
ggplot(met, aes(y = log(-ER_median), x = meanQds.lc, color = Yf)) +
  geom_point() +
  facet_grid(. ~ stream)
```


Ugh - Q and temp are correlated
These can't be in the same model

```{r}
ggplot(met, aes(y = meanQds.lc, x = Tanom.iktC, color = stream)) +
  geom_point() +
  facet_grid(stream ~.)

met %>% 
  group_by(stream) %>% 
  summarize(currelation = cor(meanQds.lc, Tanom.iktC))

```




## ER v. temp

```{r}
ggplot(met, aes(y = lER, x = Tanom.iktC, color = Yf, shape = stream)) +
  geom_point() 
```

```{r}
ggplot(met, aes(y = lER, x = Tanom.iktC, color = Yf)) +
  geom_point() +
  facet_grid(stream ~.)
```



```{r}
ggplot(met, aes(y = lER, x = invKT.C.StMean, color = Yf, shape = stream)) +
  geom_point(position = "jitter") 
```

# ER models

Likely maximal model
```{r}
g.er.PutGLOB0 <- gamm(lER ~ treatment*invKT.C.StMean +  s(meanQds.lc, by = stream) , REML = FALSE, data = met)

g.er.PutGLOB1 <- gamm(lER ~ treatment*invKT.C.StMean +  s(meanQds.lc, by = stream) + 
                     s(lGPP.c, by = stream), REML = FALSE, data = met)

g.er.PutGLOB1a <- gamm(lER ~ treatment*invKT.C.StMean +  s(meanQds.lc, by = stream), REML = FALSE, data = met)


# this is perhaps the most intuitive, but it doesn't work
# g.er.PutGLOB1 <- gamm(lER ~ s(invKT.C.StMean, by = treatment) +  s(meanQds.lc, by = stream) + 
#                      s(LightPerDay.lc, by = stream) + s(Tanom.iktC, by = stream), REML = FALSE, data = met)
```

```{r}
model.sel(g.er.PutGLOB0$lme, g.er.PutGLOB1$lme, g.er.PutGLOB1a$lme)
```


```{r}
summary(g.er.PutGLOB1$gam)
```

```{r}
g.er.PutGLOB0.b <- getViz(g.er.PutGLOB1$gam)
```

```{r}
check(g.er.PutGLOB0.b)
```


So autocorrelation
```{r}
# https://www.kaggle.com/timib1203/managing-many-models-with-tidyr-purrr-and-broom
met.PutGLOB <- met %>% 
  mutate(g.erRes = resid(g.er.PutGLOB1$lme, type = "normalized")) %>% 
  select(streamTreat, g.erRes) %>% 
  group_by(streamTreat) %>% 
  nest() %>% 
  mutate(acf = map(.x = data, .f = function(d) ggAcf(d$g.erRes) + labs(title = streamTreat)))
```

```{r}
grid.arrange(grobs = met.PutGLOB$acf, ncol = 3)
```


Evaluate different corr structures
```{r}
g.er.AC_1.0 <- gamm(lER ~ treatment*invKT.C.StMean +  s(meanQds.lc, by = stream),
                correlation = corARMA(p = 1,q = 0, form = ~ doy | streamTreat), REML = FALSE, data = met)

g.er.AC_1.1 <- gamm(lER ~ treatment*invKT.C.StMean +  s(meanQds.lc, by = stream),
                correlation = corARMA(p = 1,q = 1, form = ~ doy | streamTreat), REML = FALSE, data = met)

g.er.AC_1.2 <- gamm(lER ~ treatment*invKT.C.StMean +  s(meanQds.lc, by = stream),
                correlation = corARMA(p = 1,q = 2, form = ~ doy | streamTreat), REML = FALSE, data = met)

g.er.AC_2.0 <- gamm(lER ~ treatment*invKT.C.StMean +  s(meanQds.lc, by = stream),
                correlation = corARMA(p = 2,q = 0, form = ~ doy | streamTreat), REML = FALSE, data = met)


g.er.AC_2.1 <- gamm(lER ~ treatment*invKT.C.StMean +  s(meanQds.lc, by = stream),
                correlation = corARMA(p = 2,q = 1, form = ~ doy | streamTreat), REML = FALSE, data = met)

g.er.AC_2.2 <- gamm(lER ~ treatment*invKT.C.StMean +  s(meanQds.lc, by = stream),
                correlation = corARMA(p = 2,q = 2, form = ~ doy | streamTreat), REML = FALSE, data = met)
# doesn't work
g.er.AC_3.0 <- gamm(lER ~ treatment*invKT.C.StMean +  s(meanQds.lc, by = stream),
                correlation = corARMA(p = 3,q = 0, form = ~ doy | streamTreat), REML = FALSE, data = met)

g.er.AC_3.1 <- gamm(lER ~ treatment*invKT.C.StMean +  s(meanQds.lc, by = stream),
                correlation = corARMA(p = 3,q = 1, form = ~ doy | streamTreat), REML = FALSE, data = met)
# 
g.er.AC_3.2 <- gamm(lER ~ treatment*invKT.C.StMean +  s(meanQds.lc, by = stream),
                correlation = corARMA(p = 3,q = 2, form = ~ doy | streamTreat), REML = FALSE, data = met)
```

Model selection
```{r}
model.sel(g.er.AC_1.0$lme, g.er.AC_1.1$lme, g.er.AC_1.2$lme, g.er.AC_2.0$lme,
          g.er.AC_2.1$lme, g.er.AC_2.2$lme, g.er.AC_3.0$lme, g.er.AC_3.1$lme) 

```


Much better. S6p, s6n, s9a, s9p, s11u still have some minor problems
```{r}

# https://www.kaggle.com/timib1203/managing-many-models-with-tidyr-purrr-and-broom
# https://jroy042.github.io/nonlinear/week4.html
# https://stackoverflow.com/questions/47586110/autocorrelation-in-generalized-additive-models-gam
g.er.AC_best.acf <- met %>% 
  mutate(g.erRes = resid(g.er.AC_1.2$lme, type = "normalized")) %>% 
  select(streamTreat, g.erRes) %>% 
  group_by(streamTreat) %>% 
  nest() %>% 
  mutate(acf = map(.x = data, .f = function(d) ggAcf(d$g.erRes) + labs(title = streamTreat)))
```

```{r}
grid.arrange(grobs = g.er.AC_best.acf$acf, ncol = 3)
```


Let's do some model selection. Thinking about this as our base model has Q, temp, and light. I'm not going to obsess about selecting those. Instead, I'll just focus on Annual Temp and treatment

going to use a simpler one, problems fitting models with 3.0
```{r}
BestERCor <- corARMA(p = 1,q = 2, form = ~ doy | streamTreat)
```


```{r}
# did quick check to see if I need T anom by stream - yes massive improvement in AIC
# also did check to see if I needed GPP x stream - nope! 
g.er.NutXT <- gamm(lER ~ treatment*invKT.C.StMean +  s(meanQds.lc, by = stream),
                correlation = BestERCor, REML = FALSE, data = met)

g.er.NutpT <- gamm(lER ~ treatment + invKT.C.StMean +  s(meanQds.lc, by = stream),
                correlation = BestERCor, REML = FALSE, data = met)

g.er.NutpTb <- gamm(lER ~ treatment + invKT.C.StMean +  s(meanQds.lc),
                correlation = BestERCor, REML = FALSE, data = met)

g.er.NutXst <- gamm(lER ~ treatment*stream +  s(meanQds.lc, by = stream),
                correlation = BestERCor, REML = FALSE, data = met)

g.er.Nutpst <- gamm(lER ~ treatment + stream +  s(meanQds.lc, by = stream),
                correlation = BestERCor, REML = FALSE, data = met)

g.er.Nut <- gamm(lER ~ treatment +  s(meanQds.lc, by = stream),
                correlation = BestERCor, REML = FALSE, data = met)

g.er.T <- gamm(lER ~ invKT.C.StMean +  s(meanQds.lc, by = stream),
                correlation = BestERCor, REML = FALSE, data = met)

g.er.st <- gamm(lER ~ stream +  s(meanQds.lc, by = stream),
                correlation = BestERCor, REML = FALSE, data = met)

g.er. <- gamm(lER ~ s(meanQds.lc, by = stream),
                correlation = BestERCor, REML = FALSE, data = met) 
```


Probably a tie between treatment + temp and treat + stream


```{r}
model.sel(g.er.NutXT$lme, g.er.NutpT$lme, g.er.NutXst$lme, g.er.Nutpst$lme, g.er.Nut$lme, g.er.T$lme, g.er.st$lme, g.er.$lme, g.er.NutpTb$lme)
```


```{r}
summary(g.er.NutpT$gam)
```


```{r}
g.er.NutpT.b <- getViz(g.er.NutpT$gam)
```

This model violates some shit!!! 

```{r}
check(g.er.NutpT.b)
```

```{r}
hist(resid(g.er.NutpT$lme, type = "normalized"))
```


```{r}
g.er.NutpT.acf <- met %>% 
  mutate(g.erRes = resid(g.er.NutpT$lme, type = "normalized")) %>% 
  select(streamTreat, g.erRes) %>% 
  group_by(streamTreat) %>% 
  nest() %>% 
  mutate(acf = map(.x = data, .f = function(d) ggAcf(d$g.erRes) + labs(title = streamTreat)))
```

```{r}
grid.arrange(grobs = g.er.NutpT.acf$acf, ncol = 3)
```

```{r}
met$BestMod <- predict.gam(g.er.NutpT$gam, met, type = "response")
```

```{r}
ggplot(met, aes(y = lER, x = BestMod, color = treatment)) +
  geom_point()+
  facet_grid(stream ~.) +
  geom_abline(intercept = 0, slope =1)
```


```{r}
print(plot(g.er.NutpT.b, allTerms = T), pages = 1)
```


In the splines, this shows all the data!
```{r}
blah <- plot(g.er.NutpT.b, allTerms = 1) +
  l_points(color = "blue") + l_fitLine(linetype = 3) + l_fitContour() + 
      l_ciLine(colour = 2) + l_ciBar() + l_fitPoints(size = 1, col = 2) + theme_get() + labs(title = NULL)

print(blah, pages = 1)
```










```{r}
save.image("01_ERanalysis_rdat")
# load("01_ERanalysis_rdat")
```

